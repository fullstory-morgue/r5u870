fix API redefinition for kernel 2.6.25, as expressed in:

commit 0fc0686e64d21a6abded96af2b1a895dfa8b2530
Author: Brandon Philips <brandon@ifup.org>
Date:   Tue Nov 6 20:02:36 2007 -0300

    V4L/DVB (6600): V4L: videobuf: don't chew up namespace STATE_.*, convert to VIDEOBUF_

    s/STATE_NEEDS_INIT/VIDEOBUF_NEEDS_INIT/g
    s/STATE_PREPARED/VIDEOBUF_PREPARED/g
    s/STATE_QUEUED/VIDEOBUF_QUEUED/g
    s/STATE_ACTIVE/VIDEOBUF_ACTIVE/g
    s/STATE_DONE/VIDEOBUF_DONE/g
    s/STATE_ERROR/VIDEOBUF_ERROR/g
    s/STATE_IDLE/VIDEOBUF_IDLE/g

    Signed-off-by: Brandon Philips <bphilips@suse.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>

Signed-off-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>

--- a/usbcam/usbcam_buf.c
+++ b/usbcam/usbcam_buf.c
@@ -25,6 +25,14 @@
  * current frame access functions.
  */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
+#define VIDEOBUF_NEEDS_INIT STATE_NEEDS_INIT
+#define VIDEOBUF_PREPARED STATE_PREPARED
+#define VIDEOBUF_ACTIVE STATE_ACTIVE
+#define VIDEOBUF_DONE STATE_DONE
+#define VIDEOBUF_DONE STATE_ERROR
+#endif
+
 /*
  * APPBUG: Some applications expect VIDIOCGMBUF to provide a buffer
  * large enough to accommodate whatever image format they choose in the
@@ -58,10 +66,10 @@
 		framep = usbcam_capture_curframe(udp);
 		if (!framep)
 			break;
-		usbcam_dbg(udp, VIDEOBUF, "completing frame %d STATE_ERROR",
+		usbcam_dbg(udp, VIDEOBUF, "completing frame %d VIDEOBUF_ERROR",
 			   framep->vbb.i);
 		list_del_init(&framep->cap_links);
-		framep->vbb.state = STATE_ERROR;
+		framep->vbb.state = VIDEOBUF_ERROR;
 		wake_up_all(&framep->vbb.done);
 	}
 }
@@ -72,9 +80,9 @@
 {
 	usbcam_chklock(udp);
 	usbcam_dbg(udp, VIDEOBUF, "completing frame %d/%p %s", framep->vbb.i,
-		   framep, is_error ? "STATE_ERROR" : "STATE_DONE");
+		   framep, is_error ? "VIDEOBUF_ERROR" : "VIDEOBUF_DONE");
 	list_del_init(&framep->cap_links);
-	framep->vbb.state = is_error ? STATE_ERROR : STATE_DONE;
+	framep->vbb.state = is_error ? VIDEOBUF_ERROR : VIDEOBUF_DONE;
 	wake_up_all(&framep->vbb.done);
 }
 
@@ -194,7 +202,7 @@
 		return;
 	}
 
-	if (framep->vbb.state != STATE_ACTIVE) {
+	if (framep->vbb.state != VIDEOBUF_ACTIVE) {
 		usbcam_err(udp, "%s: current frame is in unexpected state %d",
 			   __FUNCTION__, framep->vbb.state);
 	}
@@ -516,14 +524,14 @@
 	videobuf_waiton(&framep->vbb, 0, 0);
 	videobuf_dma_unmap(vq, dma);
 	videobuf_dma_free(dma);
-	if (framep->vbb.state != STATE_NEEDS_INIT) {
+	if (framep->vbb.state != VIDEOBUF_NEEDS_INIT) {
 		if (framep->vmap_base) {
 			vunmap(framep->vmap_base);
 			framep->vmap_base = NULL;
 			framep->vmap_sof = NULL;
 		}
 		assert(list_empty(&framep->cap_links));
-		framep->vbb.state = STATE_NEEDS_INIT;
+		framep->vbb.state = VIDEOBUF_NEEDS_INIT;
 	}
 }
 
@@ -546,7 +554,7 @@
 		return -EINVAL;
 	}
 
-	if (framep->vbb.state == STATE_NEEDS_INIT) {
+	if (framep->vbb.state == VIDEOBUF_NEEDS_INIT) {
 		/*
 		 * This is the place where we initialize the rest of
 		 * the usbcam_frame structure.
@@ -581,7 +589,7 @@
 	}
 
 	framep->vbb.field = field;
-	framep->vbb.state = STATE_PREPARED;
+	framep->vbb.state = VIDEOBUF_PREPARED;
 	return 0;
 
 fail:
@@ -598,7 +606,7 @@
 		container_of(vb, struct usbcam_frame, vbb);
 	int was_empty = 0;
 
-	assert(framep->vbb.state != STATE_NEEDS_INIT);
+	assert(framep->vbb.state != VIDEOBUF_NEEDS_INIT);
 
 	usbcam_lock(udp);
 
@@ -609,11 +617,11 @@
 		   framep->vbb.i, framep);
 
 	/*
-	 * We always set buffers to STATE_ACTIVE to prevent them from
+	 * We always set buffers to VIDEOBUF_ACTIVE to prevent them from
 	 * being manipulated / dequeued by the videobuf code.
 	 */
 	list_add_tail(&framep->cap_links, &udp->ud_frame_cap_queue);
-	framep->vbb.state = STATE_ACTIVE;
+	framep->vbb.state = VIDEOBUF_ACTIVE;
 
 	if (was_empty && !udp->ud_capturing)
 		(void) usbcam_capture_start(udp);
@@ -632,7 +640,7 @@
 
 	usbcam_lock(udp);
 
-	if ((framep->vbb.state != STATE_NEEDS_INIT) &&
+	if ((framep->vbb.state != VIDEOBUF_NEEDS_INIT) &&
 	    !list_empty(&framep->cap_links)) {
 
 		usbcam_dbg(udp, VIDEOBUF,
@@ -642,7 +650,7 @@
 		 * An active frame is being shot down here, most
 		 * likely by videobuf_queue_cancel.
 		 */
-		assert(framep->vbb.state == STATE_ACTIVE);
+		assert(framep->vbb.state == VIDEOBUF_ACTIVE);
 
 		if (udp->ud_capturing &&
 		    !list_empty(&udp->ud_frame_cap_queue) &&
